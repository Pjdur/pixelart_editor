<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Sprite Editor</title>
        <style>
            body {
                display: flex;
                flex-direction: column;
                align-items: center;
                background: #222;
                color: white;
                font-family: sans-serif;
            }
            canvas {
                border: 4px solid white;
                image-rendering: pixelated;
                cursor: crosshair;
                margin-top: 10px;
            }
            .palette {
                margin-top: 10px;
            }
            .color {
                display: inline-block;
                width: 24px;
                height: 24px;
                margin: 2px;
                border: 2px solid white;
                cursor: pointer;
            }
            button,
            select {
                margin-top: 10px;
                padding: 6px 12px;
                font-size: 14px;
            }
            .button-row {
                display: flex;
                gap: 10px;
                margin-top: 10px;
            }
        </style>
    </head>

    <body>
        <label>Grid Size:</label>
        <select id="gridSize">
            <option value="8">8x8</option>
            <option value="16">16x16</option>
            <option value="32">32x32</option>
        </select>

        <label>Export Size:</label>
        <select id="exportSize">
            <option value="64">64px</option>
            <option value="128" selected>128px</option>
            <option value="256">256px</option>
        </select>

        <!-- layered canvases -->
        <div style="position: relative">
            <canvas id="bg" width="256" height="256"></canvas>
            <canvas
                id="sprite"
                width="256"
                height="256"
                style="position: absolute; left: 0; top: 0"
            ></canvas>
            <canvas
                id="grid"
                width="256"
                height="256"
                style="
                    position: absolute;
                    left: 0;
                    top: 0;
                    pointer-events: none;
                "
            ></canvas>
        </div>

        <div class="palette">
            <div class="color" style="background: #ff595e"></div>
            <div class="color" style="background: #ffca3a"></div>
            <div class="color" style="background: #8ac926"></div>
            <div class="color" style="background: #1982c4"></div>
            <div class="color" style="background: #6a4c93"></div>
            <div class="color" style="background: #000000"></div>
            <div class="color" style="background: #ffffff"></div>
        </div>

        <div class="button-row">
            <button id="undo">Undo</button>
            <button id="redo">Redo</button>
        </div>
        <button id="save">Save PNG</button>

        <script>
            const canvas = document.getElementById("sprite");
            const ctx = canvas.getContext("2d");
            ctx.imageSmoothingEnabled = false;

            const gridCanvas = document.getElementById("grid");
            const gridCtx = gridCanvas.getContext("2d");

            const bgCanvas = document.getElementById("bg");
            const bgCtx = bgCanvas.getContext("2d");

            let size = 16;
            let pixelSize = canvas.width / size;
            let currentColor = "#ff595e";
            let isDrawing = false;
            let erasing = false;

            let undoStack = [];
            let redoStack = [];

            const gridSizeSelect = document.getElementById("gridSize");

            function updateGridSize() {
                size = parseInt(gridSizeSelect.value);
                pixelSize = canvas.width / size;
                ctx.clearRect(0, 0, canvas.width, canvas.height); // optional but recommended
                drawGrid();
                saveState(); // so undo starts from clean state
            }

            gridSizeSelect.addEventListener("change", updateGridSize);
            updateGridSize(); // apply initial selection

            /* ---------- checkerboard ---------- */
            function drawCheckerboard() {
                const s = 16;
                for (let y = 0; y < bgCanvas.height; y += s) {
                    for (let x = 0; x < bgCanvas.width; x += s) {
                        bgCtx.fillStyle = (x / s + y / s) % 2 ? "#444" : "#555";
                        bgCtx.fillRect(x, y, s, s);
                    }
                }
            }
            drawCheckerboard();

            /* ---------- grid ---------- */
            function drawGrid() {
                gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
                gridCtx.strokeStyle = "rgba(255,255,255,0.15)";

                for (let i = 0; i <= size; i++) {
                    const p = i * pixelSize;
                    gridCtx.beginPath();
                    gridCtx.moveTo(p, 0);
                    gridCtx.lineTo(p, gridCanvas.height);
                    gridCtx.stroke();

                    gridCtx.beginPath();
                    gridCtx.moveTo(0, p);
                    gridCtx.lineTo(gridCanvas.width, p);
                    gridCtx.stroke();
                }
            }
            drawGrid();

            /* ---------- state ---------- */
            function saveState() {
                undoStack.push(canvas.toDataURL());
                redoStack = [];
            }

            function restoreState(state) {
                const img = new Image();
                img.src = state;
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
            }

            /* ---------- drawing ---------- */
            function drawPixel(e) {
                saveState();
                const r = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - r.left) / pixelSize);
                const y = Math.floor((e.clientY - r.top) / pixelSize);

                if (erasing) {
                    ctx.clearRect(
                        x * pixelSize,
                        y * pixelSize,
                        pixelSize,
                        pixelSize,
                    );
                } else {
                    ctx.fillStyle = currentColor;
                    ctx.fillRect(
                        x * pixelSize,
                        y * pixelSize,
                        pixelSize,
                        pixelSize,
                    );
                }
            }

            canvas.addEventListener("mousedown", (e) => {
                isDrawing = true;
                drawPixel(e);
            });
            canvas.addEventListener("mouseup", () => (isDrawing = false));
            canvas.addEventListener("mouseleave", () => (isDrawing = false));
            canvas.addEventListener(
                "mousemove",
                (e) => isDrawing && drawPixel(e),
            );

            /* ---------- erase toggle (hold E) ---------- */
            window.addEventListener("keydown", (e) => {
                if (e.key === "e") erasing = true;
            });
            window.addEventListener("keyup", (e) => {
                if (e.key === "e") erasing = false;
            });

            /* ---------- palette ---------- */
            document.querySelectorAll(".color").forEach((el) => {
                el.onclick = () => (currentColor = el.style.background);
            });

            /* ---------- crop ---------- */
            function cropCanvas(source) {
                const ctx = source.getContext("2d");
                const { width, height } = source;
                const data = ctx.getImageData(0, 0, width, height).data;

                let minX = width,
                    minY = height,
                    maxX = 0,
                    maxY = 0,
                    found = false;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (data[(y * width + x) * 4 + 3] > 0) {
                            found = true;
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                if (!found) return source;

                const w = maxX - minX + 1;
                const h = maxY - minY + 1;
                const out = document.createElement("canvas");
                out.width = w;
                out.height = h;
                out.getContext("2d").drawImage(
                    source,
                    minX,
                    minY,
                    w,
                    h,
                    0,
                    0,
                    w,
                    h,
                );
                return out;
            }

            /* ---------- export ---------- */
            document.getElementById("save").onclick = () => {
                const exportSize = parseInt(
                    document.getElementById("exportSize").value,
                );

                const cropped = cropCanvas(canvas);

                const out = document.createElement("canvas");
                out.width = exportSize;
                out.height = exportSize;

                const octx = out.getContext("2d");
                octx.imageSmoothingEnabled = false;
                octx.drawImage(cropped, 0, 0, exportSize, exportSize);

                const a = document.createElement("a");
                a.download = "sprite.png";
                a.href = out.toDataURL();
                a.click();
            };
        </script>
    </body>
</html>
